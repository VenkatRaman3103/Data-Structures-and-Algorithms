## General Problem-Solving Patterns

1. **Hash Maps/Tables** - O(1) lookups, tracking frequencies, finding duplicates
2. **Two Pointers** - Processing arrays/strings with multiple positions simultaneously
3. **Sliding Window** - Processing subarrays/substrings of variable or fixed length
4. **Binary Search** - Finding elements in sorted arrays or search spaces
5. **Breadth-First Search (BFS)** - Level-by-level graph/tree traversal
6. **Depth-First Search (DFS)** - Exploring branches fully before backtracking
7. **Recursion** - Breaking problems into smaller self-similar subproblems
8. **Dynamic Programming** - Solving complex problems by breaking into overlapping subproblems
9. **Greedy Algorithms** - Making locally optimal choices
10. **Divide and Conquer** - Splitting problems into non-overlapping subproblems
11. **Backtracking** - Building solutions incrementally and abandoning paths
12. **Graph Traversal** - Specialized algorithms for network problems
13. **Prefix Sums** - Computing range sums efficiently
14. **Binary Manipulation** - Working with bits for optimization
15. **Monotonic Stack/Queue** - Tracking the next/previous greater/smaller element

## Specific-Purpose Tools

1. **Union Find/Disjoint Set** - For connectivity problems and detecting cycles
2. **Tries** - For prefix matching and word dictionary problems
3. **Segment Trees** - For range queries with updates
4. **Fenwick Trees (Binary Indexed Trees)** - For prefix sums with updates
5. **Priority Queues/Heaps** - For maintaining sorted elements with insertions
6. **Topological Sort** - For dependency ordering
7. **Shortest Path Algorithms** (Dijkstra's, Bellman-Ford, Floyd-Warshall)
8. **Minimum Spanning Tree** (Prim's, Kruskal's)
9. **KMP Algorithm** - For pattern matching in strings
10. **Rabin-Karp Algorithm** - For multiple pattern matching
11. **Z Algorithm** - For pattern matching problems
12. **Manacher's Algorithm** - For palindrome problems
13. **Kadane's Algorithm** - For maximum subarray problems
14. **Fisher-Yates Shuffle** - For randomly shuffling arrays
15. **LRU Cache** - For caching mechanisms
16. **Bloom Filters** - For membership testing
17. **Dutch National Flag Algorithm** - For three-way partitioning
18. **Fast Exponentiation** - For computing powers efficiently
19. **Line Sweep Algorithms** - For geometric problems
20. **Convex Hull Algorithms** - For finding convex shapes in points
21. **Quickselect (Hoare's Selection Algorithm)** - For finding kth smallest/largest elements in O(n) average time
22. **Reservoir Sampling** - For randomly selecting k items from a stream of unknown size
23. **Two Heaps Pattern** - For median finding problems with insertions
24. **Interval Merging** - For overlapping interval problems
25. **Meeting Rooms Pattern** - For scheduling and interval conflict resolution
26. **Bucket Sort/Counting Sort** - For sorting when values have a limited range
27. **Radix Sort** - For linear-time sorting when items have finite representation
28. **State Machines** - For parsing and processing sequential inputs

## More Specialized Algorithms

29. **A\* Search Algorithm** - For informed pathfinding with heuristics
30. **Bidirectional Search** - For faster path finding between two nodes
31. **Euler Path/Circuit** - For traversing each edge exactly once
32. **Tarjan's Algorithm** - For strongly connected components
33. **Kosaraju's Algorithm** - Alternative for strongly connected components
34. **Johnson's Algorithm** - For all-pairs shortest paths in sparse graphs
35. **Boyer-Moore Majority Vote** - For finding majority elements
36. **Morris Traversal** - For tree traversal with O(1) space
37. **Lowest Common Ancestor (LCA)** - For hierarchical relationship problems
38. **Heavy-Light Decomposition** - For path queries on trees
39. **Suffix Trees/Arrays** - For complex string operations
40. **Aho-Corasick Algorithm** - For multiple pattern string matching
41. **Bipartite Matching** - For assignment problems
42. **Ford-Fulkerson/Edmonds-Karp** - For maximum flow problems
43. **Min-Cut Max-Flow** - For network flow problems
44. **Hungarian Algorithm** - For assignment optimization problems
45. **Cycle Detection** (Floyd's Tortoise and Hare) - For linked list cycles

## Advanced Data Structures

46. **Red-Black Trees** - Self-balancing binary search trees
47. **AVL Trees** - Height-balanced binary search trees
48. **B-Trees/B+ Trees** - For database and file system indexing
49. **Skip Lists** - Probabilistic alternative to balanced trees
50. **Sparse Tables** - For static range queries
51. **Persistent Data Structures** - For maintaining versions of data
52. **Van Emde Boas Trees** - For integer operations with bounded universe
53. **Treap** - Tree-heap hybrid for balanced BSTs
54. **Rope** - For efficient string operations
55. **Splay Trees** - Self-adjusting BSTs with amortized efficiency

# Data Structures

### Linear Data Structures

1. **Arrays** - Contiguous memory blocks for fast access by index
2. **Linked Lists** - Single, double, and circular for dynamic element management
3. **Stacks** - LIFO (Last In, First Out) data structure
4. **Queues** - FIFO (First In, First Out) data structure
5. **Deques** - Double-ended queues allowing insertion/deletion at both ends
6. **Priority Queues/Heaps** - Efficient max/min element access
   - Binary Heaps
   - Fibonacci Heaps
   - Binomial Heaps
   - Pairing Heaps

### Tree Data Structures

1. **Binary Trees** - Trees with at most two children per node
2. **Binary Search Trees** - Ordered binary trees for efficient searches
3. **AVL Trees** - Self-balancing binary search trees
4. **Red-Black Trees** - Self-balancing BSTs with guaranteed O(log n) operations
5. **B-Trees/B+ Trees** - Balanced trees optimized for disk operations and databases
6. **Splay Trees** - Self-adjusting BSTs that move frequently accessed nodes to root
7. **Treaps** - Tree-heap hybrids using random priorities
8. **Segment Trees** - For range queries and updates
9. **Fenwick Trees (Binary Indexed Trees)** - For prefix sums with updates
10. **Tries (Prefix Trees)** - For efficient string operations and prefix matching
11. **Suffix Trees/Arrays** - For complex string searching
12. **Ternary Search Trees** - Space-efficient tries with three children per node
13. **Radix Trees** - Space-optimized prefix trees
14. **Merkle Trees** - Hash trees used in cryptography and distributed systems
15. **K-d Trees** - For multidimensional search spaces
16. **Quad Trees** - For 2D space partitioning
17. **Oct Trees** - For 3D space partitioning
18. **R-Trees** - For spatial indexing of multidimensional data

### Graph Data Structures

1. **Adjacency Matrix** - Matrix representation of graph edges
2. **Adjacency List** - List representation of graph connections
3. **Edge List** - Simple list of all edges in a graph
4. **Incidence Matrix** - Matrix showing relationships between vertices and edges
5. **Compressed Sparse Row (CSR)** - Memory-efficient graph representation

### Hash-Based Structures

1. **Hash Tables/Maps** - For O(1) average time lookup
2. **Hash Sets** - For fast membership testing
3. **Bloom Filters** - Probabilistic data structure for membership queries
4. **Cuckoo Hashing** - Technique for resolving hash collisions
5. **Robin Hood Hashing** - Technique to minimize probe sequence length
6. **Count-Min Sketch** - Probabilistic frequency counter
7. **HyperLogLog** - For approximate cardinality counting
8. **Consistent Hashing** - For distributed caching systems
9. **Perfect Hashing** - For static sets with guaranteed O(1) lookup

### Advanced Data Structures

1. **Skip Lists** - Probabilistic alternative to balanced trees
2. **Van Emde Boas Trees** - For integer operations with bounded universe
3. **Rope** - For efficient string operations
4. **Persistent Data Structures** - For maintaining versions of data
5. **Disjoint Set/Union Find** - For dynamic connectivity queries
6. **Sparse Tables** - For static range queries
7. **Wavelet Trees** - For rank/select operations on sequences
8. **Cartesian Trees** - Binary trees derived from sequence priorities
9. **DAWG (Directed Acyclic Word Graph)** - For dictionary matching
10. **Inverted Index** - For full-text search
11. **Self-Organizing Lists** - Lists that reorder based on access patterns
12. **Bitmaps/Bitsets** - Compact representation of sets of small integers
13. **Interval Trees** - For range overlap queries
14. **LRU/LFU Cache** - For caching implementations
15. **MultiMap** - Maps with multiple values per key
16. **MultiSet (Bag)** - Sets with duplicates allowed
17. **Temporal Data Structures** - For time-series data
18. **Succinct Data Structures** - With size close to information-theoretic minimum

# DSA Learning

## Phase 1: Fundamentals

### Basic Data Structures

1. **Arrays** - Contiguous memory blocks for fast access by index
   - Static vs dynamic arrays
   - Multi-dimensional arrays
   - Array operations and time complexities
2. **Linked Lists** - Dynamic element management
   - Singly linked lists
   - Doubly linked lists
   - Circular linked lists
   - Operations and time complexities
3. **Stacks** - LIFO (Last In, First Out)
   - Implementations (array-based, linked list-based)
   - Applications (function calls, expression evaluation)
4. **Queues** - FIFO (First In, First Out)
   - Implementations (array-based, linked list-based)
   - Applications (BFS, scheduling)
5. **Deques** - Double-ended queues
   - Implementations and operations
   - Applications (sliding window problems)

### Basic Algorithms

1. **Basic Searching**
   - Linear Search
   - Binary Search
   - Jump Search
2. **Basic Sorting**
   - Bubble Sort
   - Selection Sort
   - Insertion Sort
   - Counting Sort (for limited range)

### Hash-Based Structures

1. **Hash Tables/Maps** - For O(1) average time lookup
   - Hash functions
   - Collision resolution (chaining, open addressing)
   - Applications and common problems

## Phase 2: Intermediate Concepts

### Trees and Tree Algorithms

1. **Binary Trees**
   - Traversals (inorder, preorder, postorder, level-order)
   - Basic operations and implementations
2. **Binary Search Trees (BST)**
   - Search, insert, delete operations
   - Tree balancing concepts
3. **Heaps / Priority Queues**
   - Binary Heaps (min and max)
   - Operations (heapify, insert, extract)
   - Applications (priority scheduling, heap sort)

### Intermediate Algorithms

1. **Advanced Sorting**
   - Quicksort
   - Mergesort
   - Heapsort
   - Time/space complexity analysis
2. **Pattern Matching Algorithms**
   - KMP Algorithm
   - Rabin-Karp Algorithm
   - Basic string processing

### Problem-Solving Patterns

1. **Two Pointers Technique**
   - For arrays and linked lists
   - Fast & slow pointers
2. **Sliding Window**
   - Fixed and variable size windows
   - Applications in substring problems
3. **Prefix Sums**
   - Computing range sums efficiently
   - Applications in array problems

## Phase 3: Advanced Data Structures

### Advanced Tree Structures

1. **Balanced BSTs**
   - AVL Trees
   - Red-Black Trees
   - B-Trees/B+ Trees
2. **Trie (Prefix Tree)**
   - Structure and operations
   - Applications in string problems
3. **Segment Trees**
   - Construction and operations
   - Range query problems
4. **Fenwick Trees (Binary Indexed Trees)**
   - Structure and operations
   - Prefix sum with updates

### Graph Data Structures & Algorithms

1. **Graph Representations**
   - Adjacency Matrix
   - Adjacency List
   - Edge List
2. **Graph Traversals**
   - Breadth-First Search (BFS)
   - Depth-First Search (DFS)
   - Applications and implementations
3. **Shortest Path Algorithms**
   - Dijkstra's Algorithm
   - Bellman-Ford Algorithm
   - Floyd-Warshall Algorithm
4. **Minimum Spanning Tree**
   - Prim's Algorithm
   - Kruskal's Algorithm
5. **Topological Sort**
   - Applications in dependency resolution
   - Implementations (DFS-based, Kahn's algorithm)

### Union-Find / Disjoint Set

1. **Structure and operations**
   - Find operation with path compression
   - Union operation with rank/size
   - Applications in connectivity problems

## Phase 4: Advanced Algorithmic Paradigms

### Dynamic Programming

1. **Fundamentals**
   - Memoization (top-down approach)
   - Tabulation (bottom-up approach)
   - State definition and transition
2. **Common DP Patterns**
   - 1D array problems
   - Matrix/2D array problems
   - String problems (LCS, edit distance)
   - Knapsack problems and variations

### Greedy Algorithms

1. **Principles and proof techniques**
2. **Common greedy problems**
   - Activity selection
   - Huffman coding
   - Fractional knapsack

### Divide and Conquer

1. **Principles and implementation**
2. **Analysis of D&C algorithms**
3. **Common applications**
   - Binary search
   - Merge sort
   - Quick sort
   - Strassen's matrix multiplication

### Backtracking

1. **State space tree**
2. **Pruning techniques**
3. **Common applications**
   - N-Queens
   - Sudoku solver
   - Permutations and combinations

## Phase 5: Specialized Algorithms and Techniques

### Advanced Graph Algorithms

1. **Network Flow**
   - Ford-Fulkerson Method
   - Edmonds-Karp Algorithm
   - Min-Cut Max-Flow Theorem
2. **Strongly Connected Components**
   - Tarjan's Algorithm
   - Kosaraju's Algorithm
3. **Articulation Points and Bridges**
   - Finding critical nodes/edges
4. **Lowest Common Ancestor (LCA)**
   - Binary lifting technique
   - Applications in tree problems

### String Algorithms

1. **Advanced Pattern Matching**
   - Aho-Corasick Algorithm (multiple pattern matching)
   - Z Algorithm
   - Suffix Arrays/Trees
2. **Palindromic Algorithms**
   - Manacher's Algorithm
   - Finding all palindromic substrings

### Bit Manipulation

1. **Basic operations**
   - Setting, clearing, toggling bits
   - Checking bits
2. **Common bit tricks**
   - Power of 2 checks
   - Counting set bits
   - Bit masking techniques

### Number Theory

1. **Basic Number Theory**
   - GCD and LCM (Euclidean Algorithm)
   - Modular arithmetic
   - Prime numbers and primality tests
2. **Advanced Techniques**
   - Fast exponentiation
   - Sieve of Eratosthenes
   - Chinese Remainder Theorem

## Phase 6: Advanced Optimization Techniques

### Advanced Data Structures

1. **Monotonic Stack/Queue**
   - Next greater/smaller element problems
2. **Sparse Table**
   - Static range queries
3. **Treap**
   - Tree-heap hybrid for balanced BSTs
4. **Skip List**
   - Probabilistic alternative to balanced trees

### Advanced Search Techniques

1. **A\* Search Algorithm**
   - Informed search with heuristics
2. **Bidirectional Search**
   - BFS from both start and end points
3. **Meet in the Middle**
   - Splitting search space in half

### Specialized Algorithms

1. **Kadane's Algorithm**
   - Maximum subarray sum
2. **Boyer-Moore Majority Vote**
   - Finding majority elements
3. **Dutch National Flag**
   - Three-way partitioning
4. **Two Heaps Pattern**
   - For median finding problems
5. **Interval Processing**
   - Merging, scheduling, conflicts

## Phase 7: Advanced Problem-Solving

### Computational Geometry

1. **Basic Geometric Primitives**
   - Points, lines, polygons
2. **Convex Hull Algorithms**
   - Graham Scan
   - Jarvis March
3. **Line Intersection**
   - Finding where lines meet
4. **Point in Polygon**
   - Ray casting and winding number

### Randomized Algorithms

1. **Fisher-Yates Shuffle**
   - Unbiased random permutation
2. **Reservoir Sampling**
   - Selecting k items from streaming data
3. **Randomized Quicksort**
   - Using random pivots

### Advanced Techniques for Competitive Programming

1. **Square Root Decomposition**
   - Breaking arrays into blocks
2. **Mo's Algorithm**
   - For offline range queries
3. **Heavy-Light Decomposition**
   - Path queries on trees

## Phase 8: Specialized Systems and Applications

### Advanced Data Structures for Specific Problems

1. **LRU/LFU Cache**
   - For caching implementations
2. **Bloom Filters**
   - Probabilistic membership testing
3. **Count-Min Sketch**
   - Frequency estimation
4. **HyperLogLog**
   - Cardinality estimation

### Parallel and Distributed Algorithms

1. **Map-Reduce**
   - Distributed data processing
2. **Consensus Algorithms**
   - Raft, Paxos for distributed systems
3. **Distributed Hash Tables**
   - For decentralized key-value stores

### Machine Learning Fundamentals (Algorithmic Perspective)

1. **Basic ML Algorithms**
   - K-Means Clustering
   - KNN (K-Nearest Neighbors)
   - Decision Trees
2. **Optimization Algorithms**
   - Gradient Descent
   - Principal Component Analysis

## Learning Strategy

### For Each Topic:

1. **Understand the theory** - Core concepts, time/space complexity
2. **Study implementations** - Reference code, standard library implementations
3. **Practice basic problems** - Reinforce understanding with straightforward examples
4. **Apply to medium problems** - Identify patterns and build problem-solving skills
5. **Master with complex problems** - Tackle difficult problems requiring deep understanding
6. **Review and optimize** - Revisit solutions and find more efficient approaches

### Practice Guidelines:

- Aim for ~50 problems per major section
- Start with easier problems and gradually increase difficulty
- Focus on understanding patterns rather than memorizing solutions
- Implement solutions from scratch rather than copying code
- Analyze time and space complexity for each solution
- Review and refine solutions after solving

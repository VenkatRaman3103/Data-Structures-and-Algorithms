# Data Structures & Algorithms Interview Preparation Guide

## Data Structures

### 1. **Arrays**

- Static and dynamic arrays, multi-dimensional arrays
- Array manipulation, rotation, reversal
- Subarray problems, prefix arrays
- Matrix operations and traversals

### 2. **Strings**

- String manipulation and processing
- Pattern matching and searching
- String parsing and transformation
- Character frequency and anagram problems

### 3. **Linked Lists**

- Singly, doubly, and circular linked lists
- List operations (insertion, deletion, reversal)
- Cycle detection and removal
- Merging and splitting lists

### 4. **Stacks**

- LIFO operations and applications
- Expression evaluation and parsing
- Monotonic stacks for next/previous greater elements
- Function call simulation and recursion

### 5. **Queues**

- FIFO operations and circular queues
- Deque (double-ended queue) operations
- Priority queues and heaps
- Queue-based algorithms and simulations

### 6. **Hash Tables/Hash Maps**

- Hash function design and collision handling
- Key-value pair operations
- Frequency counting and duplicate detection
- Hash-based problem solving patterns

### 7. **Trees**

- Binary trees, binary search trees (BST)
- Tree traversals (inorder, preorder, postorder)
- Tree construction and validation
- Lowest common ancestor (LCA) problems

### 8. **Advanced Trees**

- AVL trees (self-balancing BST)
- Red-Black trees
- B-trees and B+ trees
- Segment trees for range queries
- Fenwick trees (Binary Indexed Trees)

### 9. **Heaps**

- Min-heap and max-heap properties
- Heap operations (insert, delete, heapify)
- Priority queue implementations
- Heap-based sorting and selection algorithms

### 10. **Tries (Prefix Trees)**

- Trie construction and operations
- Word search and auto-completion
- Prefix matching problems
- Dictionary and word game applications

### 11. **Graphs**

- Graph representations (adjacency matrix/list)
- Directed and undirected graphs
- Weighted and unweighted graphs
- Graph property analysis

### 12. **Disjoint Set (Union-Find)**

- Union by rank and path compression
- Connectivity problems
- Cycle detection in graphs
- Dynamic connectivity queries

### 13. **Advanced Data Structures**

- Sparse tables for range queries
- Skip lists for probabilistic searching
- Bloom filters for membership testing
- LRU cache implementation

## Algorithms

### 1. **Sorting Algorithms**

- Comparison-based sorts (Quick, Merge, Heap)
- Non-comparison sorts (Counting, Radix, Bucket)
- Sorting algorithm analysis and optimization
- Custom sorting with comparators

### 2. **Searching Algorithms**

- Binary search and its variations
- Linear search optimizations
- Search in rotated/modified arrays
- Finding elements in infinite arrays

### 3. **Two Pointers Technique**

- Same direction and opposite direction pointers
- Fast and slow pointer patterns
- Three pointers for triplet problems
- Pointer manipulation in arrays and strings

### 4. **Sliding Window**

- Fixed-size and variable-size windows
- Maximum/minimum in sliding windows
- Substring and subarray problems
- Window optimization techniques

### 5. **Recursion & Backtracking**

- Recursive problem decomposition
- Backtracking with constraint satisfaction
- Generating permutations and combinations
- Maze solving and N-Queens problems

### 6. **Dynamic Programming**

- Memoization and tabulation approaches
- 1D, 2D, and multi-dimensional DP
- Optimization problems (knapsack, LIS, LCS)
- State space reduction techniques

### 7. **Greedy Algorithms**

- Activity selection and scheduling
- Huffman coding and compression
- Minimum spanning tree algorithms
- Fractional knapsack and optimization

### 8. **Divide and Conquer**

- Problem decomposition strategies
- Merge sort and quick sort analysis
- Closest pair and convex hull problems
- Master theorem applications

### 9. **Graph Traversal**

- Breadth-First Search (BFS) applications
- Depth-First Search (DFS) variations
- Topological sorting for DAGs
- Connected components analysis

### 10. **Shortest Path Algorithms**

- Dijkstra's algorithm for single-source
- Bellman-Ford for negative weights
- Floyd-Warshall for all-pairs
- A\* search with heuristics

### 11. **Minimum Spanning Tree**

- Kruskal's algorithm with Union-Find
- Prim's algorithm with priority queues
- MST properties and applications
- Network design problems

### 12. **Network Flow**

- Maximum flow (Ford-Fulkerson method)
- Edmonds-Karp algorithm
- Min-cut max-flow theorem
- Bipartite matching applications

### 13. **String Algorithms**

- Pattern matching (KMP, Rabin-Karp)
- String hashing techniques
- Longest palindromic substring
- Edit distance and string alignment

### 14. **Mathematical Algorithms**

- Number theory (GCD, LCM, primes)
- Fast exponentiation and modular arithmetic
- Combinatorics and probability
- Geometric algorithms

### 15. **Bit Manipulation**

- Bitwise operations and properties
- Bit masking for subset problems
- XOR-based problem solving
- Binary representation optimizations

### 16. **Advanced Graph Algorithms**

- Strongly connected components (Tarjan's, Kosaraju's)
- Articulation points and bridges
- Euler paths and Hamiltonian cycles
- Graph coloring problems

### 17. **Computational Geometry**

- Point and line operations
- Convex hull algorithms
- Line intersection problems
- Closest pair of points

### 18. **Game Theory & Minimax**

- Optimal strategy problems
- Minimax algorithm with alpha-beta pruning
- Nim game and variations
- Dynamic programming in games

### 19. **Randomized Algorithms**

- Monte Carlo and Las Vegas algorithms
- Reservoir sampling
- Randomized quick sort
- Probabilistic data structures

### 20. **Approximation Algorithms**

- Approximation ratios and analysis
- Greedy approximations
- Linear programming relaxations
- NP-hard problem approximations

---

## Study Strategy

For each topic:

1. **Understand the fundamentals** - Theory and implementation
2. **Solve 50 practice problems** - Start easy, progress to hard
3. **Analyze time/space complexity** - Big O notation mastery
4. **Code without IDE** - Practice whiteboard coding
5. **Explain your approach** - Communicate clearly during interviews

## Problem Difficulty Distribution

- **Easy (20 problems)**: Basic operations and simple applications
- **Medium (25 problems)**: Combinations of techniques and optimizations
- **Hard (5 problems)**: Complex scenarios and advanced optimizations

This systematic approach covering 40 major topics with 50 problems each will give you a solid foundation for technical interviews!
